倍增：
1.忘了先化到同一深度
2.最后判断u，v不相等
if (u != v)
	ans = max(ans, max(big[u][0], big[v][0]));

朱刘算法：
vis[i] = i
最后更新边的时候注意顺序
根节点的处理要很小心。root缩点之后标号也要变化。

二分图：
DAG最小路径覆盖（最小的不相交路径覆盖所有顶）=|V(G)|-最多的不相交的边
：拆点之后u->v的边变为Xu->Yv,再求最大匹配即可（不相交的边尽量多）



    最大匹配=最小点覆盖；独立数=点数-匹配数=最小边覆盖

有向无环图最小可相交路径
先求floyed求传递闭包，转化成最小不可相交路径



